'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/cours1/','title':"Cours 1",'section':"Docs",'content':"Python - Introduction #  Python est un langage de programmation interprété développé par Guido van Rossum en 1989. Langage impératif de haut-niveau doté d\u0026rsquo;une syntaxe simple, Python s\u0026rsquo;adapte à de nombreux contextes grâce à sa modularité ; une importante librairie de modules et packages permet en effet d\u0026rsquo;étendre ses capacités.\nShell et IDE #  Python possède son propre shell (interface en ligne de commande) : l\u0026rsquo;utilisateur entre une commande Python qui est interprétée immédiatement lorsque Entrée est tapée. Au lancement, le shell Python, poli, se présente :\nPython 3.7.3 (default, Mar 27 2019, 16:54:48)\n[Clang 4.0.1 (tags/RELEASE_401/final)] :: Anaconda, Inc. on darwin\nType \u0026quot;help\u0026quot;, \u0026quot;copyright\u0026quot;, \u0026quot;credits\u0026quot; or \u0026quot;license\u0026quot; for more information.\n\u0026gt;\u0026gt;\u0026gt;\nLes 3 chevrons sont l\u0026rsquo;invite (ou prompt) où les commandes seront écrites.\nIPython, un shell plus évolué, utilise [1] comme invite (où le chiffre dans les crochets s\u0026rsquo;incrémente à chaque commande.\nPour sortir du shell classique, il faut taper exit(), et exit ou quit pour sortie du shell IPython.\nOn peut tout à fait exécuter des commandes Python une à une dans le shell.\nUne commande qui renvoie un résultat est appelée expression, alors qu\u0026rsquo;une commande qui ne renvoie rien est une instruction.\nToute fonction est une expression, mais certaines ont en plus un effet sur l\u0026rsquo;environnement comme print() qui permet d\u0026rsquo;afficher une chaîne de caractère dans le shell ou dans un fichier (elle retourne aussi la valeur none qui est omise dans ce cas par le shell).\n5 + 2 7\na = 7 print(a) 7\nPour des projets plus complexes nécessitant de nombreuses instructions ou expressions, on écrit l\u0026rsquo;ensemble de ces commandes (=le programme) dans un éditeur de texte et on enregistre le fichier avec une extension .py. On demande alors à l\u0026rsquo;interprète Python d\u0026rsquo;exécuter l\u0026rsquo;ensemble du script en utilisant la commande python nom_du_fichier.py dans le shell de l\u0026rsquo;OS. L\u0026rsquo;interprète n\u0026rsquo;affiche plus, dans ce cas, les différents retours dans le shell, seuls les effets ont un\u0026hellip; effet.\nIl est important d\u0026rsquo;ajouter des commentaires à son code dans le script afin qu\u0026rsquo;il soit plus facilement compréhensible et donc partageable. Pour ce faire on les place derrière un hastag # pour qu\u0026rsquo;ils soient ignorés par l\u0026rsquo;interprète.\nMais le plus simple est d\u0026rsquo;utiliser un environnement de travail (IDE pour \u0026ldquo;integrated development environment\u0026rdquo;) qui combine un éditeur de texte et un shell Python et qui permet d\u0026rsquo;exécuter le script entier ou une partie directement via un bouton run ou exécuter. Les oraux de Centrale \u0026ldquo;Mathématiques 2\u0026rdquo; et \u0026ldquo;Physique-chimie 2\u0026rdquo; utilisent l\u0026rsquo;IDE Pyzo. Les ordinateurs du lycée ont les IDE EduPython et Pyzo disponibles sur le serveur S:\\. Vous pouvez aussi utiliser pour dépanner l\u0026rsquo;IDE minimale en ligne Repl.it depuis le repository du TP.\n Types de nombres #  Les nombres sont parmi les objets Python les plus basiques.\nIl en existe 3 types :\n les entiers (type : int).\nIls n\u0026rsquo;ont pas de limite de taille (à part la mémoire vive disponible de l\u0026rsquo;ordinateur).\nL\u0026rsquo;arithmétique sur les entiers est exacte. les nombres à virgule flottante (type : float).\nCe sont des nombres décimaux. Ils sont stockés en binaire jusqu\u0026rsquo;à une certaine précision (l\u0026rsquo;équivalent de 15 ou 16 chiffres en écriture décimale sur la plupart des systèmes). Ils ne peuvent donc en général pas représenter fidèlement un nombre réel. On reviendra sur ce point plus tard.\nRq : c\u0026rsquo;est un point \u0026ldquo;.\u0026rdquo; et non une virgule \u0026ldquo;,\u0026rdquo; qui sépare la partie entière de la partie décimale en Python. les nombres complexes (type : complex).\nNombre de type 4+3j (la partie imaginaire est notée j en python).\n4+3j peut aussi s\u0026rsquo;écrire complex(4,3).  Taper un nombre dans le shell Python renvoie simplement la nombre :\n5 5\n5. 5.0\n0.10 0.1\n0.0001 0.0001\n0.0000999 9.99e-05\nLes nombres inférieurs à 0,0001 sont écrits en notation scientifique.\nOn peut changer le type d\u0026rsquo;un nombre :\nfloat(5) 5.0\nint(5.2) 5\nint(5.9) 5\ncomplex(3.) (3+0j)\ncomplex(0.,3.) 3j\nOn remarque que la transformation en entier d\u0026rsquo;un nombre décimal prend en fait sa partie entière.\nArithmétique de base #  Les opérateurs de base utilisables en Python sont :\n   symbole opération     + addition   - soustraction   * multiplication   / division décimale   // division euclidienne   % modulo (reste de la division euclidienne)   ** puissance    Règles de priorités des opérations :\n** \u0026gt; { * ,/ , // , % } \u0026gt; { + , - }\n6 / 2 / 4 # comme 3 / 4 0.75\n6 / (2 / 4) # comme 6 / 0.5 12.0\n2**2**3 # comme 2**(2**3) == 2**8 256\n(2**2)**3 # comme 4**3 64\nOn remarque que les opérations de priorité égale sont évaluées de gauche à droite à l\u0026rsquo;exception des puissances (ce qui correspond à évaluer de haut en bas les exposants).\nMéthodes et attributs #  En Python, tout, y compris un nombre, est un objet ayant certains attributs accessibles grâce à la notation \u0026ldquo;point\u0026rdquo; : \u0026lt;objet\u0026gt;.\u0026lt;attribut\u0026gt;. Certains attributs sont des simples valeurs : les nombres complexes ont par exemple les attributs real et imag qui sont les parties réelles et imaginaires d\u0026rsquo;un nombre complexe.\n(3+4j).imag 4.0\nD\u0026rsquo;autres attributs sont des méthodes : des fonctions qui modifient leur objet d\u0026rsquo;une façon ou d\u0026rsquo;une autre.\nPar exemple, les nombres complexes ont la méthode conjugate qui retourne le complexe conjugué :\n(3+4j).conjugate() (3-4j)\nFonctions mathématiques #  round et abs sont deux fonctions proposées par défaut (natives).\nabs retourne la valeur absolue d\u0026rsquo;un nombre entier ou décimal, ou le module d\u0026rsquo;un nombre complexe (c\u0026rsquo;est un exemple de polymorphisme : comportement différent en fonction du type de l\u0026rsquo;argument).\nabs(-7.2) 7.2\nabs(3+4j) 5.0\nround arrondi un nombre décimal à l\u0026rsquo;entier le plus proche (attention, la convention utilisée lorsque la décimale vaut 5 est l\u0026rsquo;arrondi bancaire ou arrondi au pair le plus proche : au-dessus lorsque la partie entière est impaire et en dessous lorsqu\u0026rsquo;elle est paire).\nround(7.6) 8\nround(7.5) 8\nround(8.5) 8\nPython est un langage d\u0026rsquo;une grande modularité : des fonctionnalités supplémentaires sont accessibles en important des modules ou des packages qui ne sont pas chargés par défaut (ce qui permet de ne pas encombrer la mémoire).\nBeaucoup de fonctions mathématiques utiles peuvent ainsi être ajoutées grâce au module math, importé grâce à la déclaration import math.\nimport math math.exp(-1.5) 0.22313016014842982\nmath.cos(0) 1.0\nmath.sqrt(9) 3.0\nL\u0026rsquo;ensemble des fonctions disponibles dans le module sont répertoriées dans sa documentation en ligne et les plus utiles sont dans le tableau suivant (les angles des fonctions trigonométriques sont supposés en radians) :\n   nom de la fonction signification nom de la fonction signification     math.sqrt(x) $$\\sqrt{x}$$ math.atan(x) $$\\arctan (x)$$   math.exp(x) $$e^x$$ math.sinh(x) $$\\sinh (x)$$   math.log(x) $$\\ln (x)$$ math.cosh(x) $$\\cosh (x)$$   math.log(x,b) $$\\log_b(x)$$ math.tanh(x) $$\\tanh (x)$$   math.log10(x) $$\\log_{10}(x)$$ math.asinh(x) $$\\text{arsinh} (x)$$   math.sin(x) $$\\sin (x)$$ math.acosh(x) $$\\text{arcosh} (x)$$   math.cos(x) $$\\cos (x)$$ math.atanh(x) $$\\text{artanh} (x)$$   math.tan(x) $$\\tan (x)$$ math.hypot(x,y) norme euclidienne $$\\sqrt{x^2+y^2}$$   math.asin(x) $$\\arcsin (x)$$ math.degrees(x) convertit x des radians aux degrés   math.acos(x) $$\\arccos (x)$$ math.radians(x) convertit x des degrés aux radians    Le module math propose aussi deux attributs très utiles : math.pi et math.e qui donnent les valeurs de $$\\pi$$ et $$e$$.\nIl est possible d\u0026rsquo;importer le module math par la commande from math import * afin d\u0026rsquo;accéder à ses fonctions directement :\nfrom math import * cos(pi) -1.0\nBien que cela puisse être pratique pour des petites interactions avec le shell, ce n\u0026rsquo;est pas recommandé pour des programmes plus conséquent car cela peut générer confusions et conflits de noms.\nOn peut bien sûr composer les fonctions :\nmath.degrees(math.acos(math.sqrt(3)/2)) 30.000000000000004\nNotons que le nombre affiché diffère du résultat exact attendu $$\\arccos(\\sqrt{3}/2)=30°$$ (on reviendra sur ce point plus tard).\nVariables #  Lorsqu\u0026rsquo;un objet, comme un float, est créé dans un programme Python, une certaine place en mémoire lui est allouée. Cette place est repérée par une adresse dont la valeur peut être obtenue grâce à la fonction id().\nid(3.7) 4387417928\nIl est beaucoup plus pratique de pouvoir récupérer une valeur en mémoire grâce à un petit nom plutôt que par son adresse. C\u0026rsquo;est à ça que servent les variables. Une variable est liée à un objet grâce à une affectation et identifie cet objet pour les calculs suivants.\na = 3 b = -0.1 a * b -0.30000000000000004\nÀ nouveau, le résultat décimal affiché est un peu étrange mais nous y reviendrons.\nSi on veut pouvoir utiliser le résultat de a * b pour des calculs ultérieurs, il faut lui aussi le stocker en mémoire.\nc = a * b c -0.30000000000000004\nRemarque : contrairement à d\u0026rsquo;autres langages (comme le C), une variable n\u0026rsquo;a pas besoin d\u0026rsquo;être déclarée en Python, mais il faut néanmoins initialiser sa valeur pour ne pas provoquer d\u0026rsquo;erreur. Le type de la variable est induit au moment de cette première affectation.\n3+x NameError: name 'x' is not defined\nOn peut interroger le type d\u0026rsquo;une variable avec la fonction type() :\ntype(c) float\nRègles sur les noms de variables :\n ils sont sensibles à la casse (minuscule ou majuscule) ils peuvent contenir n\u0026rsquo;importe quelles lettres ou chiffres et le tiret-bas \u0026ldquo;_\u0026rdquo; mais ne doivent pas commencer par un chiffre. certains noms sont interdits (attention en particulier à lambda) :  and assert break class continue def del elif else except finally for from global if import in is lambda nonlocal not or pass print raise return try while yield\nIl est important pour la lisibilité de son code de donner les noms les plus explicites possibles aux variables. Les rapports de jury le répète tous les ans\u0026hellip; Rapport 2019 de l\u0026rsquo;épreuve de Centrale par exemple :\n Des noms de variables explicites aident à la compréhension du code. De trop nombreux candidats utilisent des noms de variables quelconques (a, b, c\u0026hellip;) ce qui nuit à la compréhension du programme. La clarté du programme (en particulier le choix des noms de variables) ainsi que la présence de commentaires opportuns sont prises en compte dans l’évaluation.\n Une affectation ne retourne rien (c\u0026rsquo;est une instruction) mais a un effet sur la mémoire : l\u0026rsquo;adresse de la variable est modifiée à chaque nouvelle affectation. C\u0026rsquo;est ce qui rend possible les réaffectations à partir de la variable elle-même.\nid(a) 4304751488\nid(a+1) 4304751520\na = a + 1 id(a) 4304751520\nLes réaffectations de variable de ce type sont si fréquentes qu\u0026rsquo;il existe une notation raccourcie : +=, -=, *=, /=, //=, %=.Ainsi, a += 1 équivaut à a = a + 1 et b /= 5 équivaut à b = b/5.\nPython permet d'affecter plusieurs variables simultanément (en parallèle) :\na , b = 3.2 , -2 a 3.2\nb -2\nComment faire si on veut permuter les valeurs auxquelles sont liées deux variables ? Dès qu\u0026rsquo;on écrit a = b, la valeur initiale de a est perdue et si on commence par b = a, c\u0026rsquo;est la valeur initiale de b qui est perdue. Il faudrait donc utiliser une variable temporaire et écrire : tmp = a, a = b et b = tmp. Mais l\u0026rsquo;affectation parallèle de Python va nous permettre d\u0026rsquo;être plus élégants. Il suffit en effet d\u0026rsquo;une petite ligne :\na , b = b , a a -2\nb 3.2\nL\u0026rsquo;affectation parallèle repose sur le packing et l\u0026rsquo;unpacking de tuples, mais on verra ça dans un prochain cours.\nComparaison et logique #  Les différents comparateurs utilisables en Python sont :\n   comparateur signification     == égal à   != différent de   \u0026gt; supérieur à   \u0026lt; inférieur à   \u0026gt;= supérieur ou égal à   \u0026lt;= inférieur ou égal à    Le résultat d\u0026rsquo;une comparaison est un objet booléen (type bool) qui a deux valeurs possibles : True ou False.\n7 == 8 False\n4 \u0026gt;= 3.8 True\na = 4 \u0026lt; 3 type(a) bool\nIl faut bien noter la différence entre = qui affecte une valeur à une variable et == qui compare deux valeurs.\nDu fait de la précision finie des nombres décimaux, leur comparaison peut s\u0026rsquo;avérer dangereuse :\na , b = 0.01 , 0.1**2 a == b False\nEn effet :\na 0.01\nb 0.010000000000000002\nLes comparaisons peuvent être modifiées et enchaînées grâce aux opérateurs logiques and (et), or (ou inclusif), et not (non).\n7.0 \u0026gt; 4 and -1 \u0026gt;= 0 False\n5 \u0026lt; 4 or 1 != 0 True\nDans des expressions composées comme celles-ci, les opérateurs de comparaison sont évalués en premier puis vient le tour des opérateurs logiques.\nnot 7.5 \u0026lt; 0.9 or 4 == 4 True\nnot (7.5 \u0026lt; 0.9 or 4 == 4) False\nUn nombre entier ou décimal peut être considéré comme un booléen dans des expressions logiques. Dans ce cas, tout nombre différent de zéro est considéré comme vrai.\n18.7 and 5 \u0026lt; 8 True\nOn parle d'égalité de valeurs (testée par l\u0026rsquo;opérateur ==) lorsque deux variables référencent la même valeur et d'égalité physique lorsqu\u0026rsquo;il s\u0026rsquo;agit du même objet ayant un emplacement mémoire unique. L\u0026rsquo;égalité physique implique bien sûr l\u0026rsquo;égalité de valeurs.\nPour tester l\u0026rsquo;égalité physique de deux variables, on utilise l\u0026rsquo;opérateur is.\na = 257 b = 257 a == b True\na is b False\na is 257 False\nid(a) 4396188400\nid(b) 4396188144\nid(257) 4396188272\nc = 256 d = 256 c is d True\nc is 256 True\nid(c) 4304759584\nid(d) 4304759584\nid(256) 4304759584\nPython garde en cache les petits entiers (de -5 à 256 généralement), souvent utilisés, pour améliorer les performances. a et b sont alors tout deux liés à l\u0026rsquo;espace mémoire de l\u0026rsquo;objet 256. Ils correspondent donc bien au même objet physique.\nType None #  Enfin, pour nous aider à traiter les cas où aucune valeur définie n\u0026rsquo;est possible (soit parceque la valeur conduirait à une erreur où n\u0026rsquo;aurait pas de sens), Python propose d\u0026rsquo;utiliser la valeur None de type NoneType.\nC\u0026rsquo;est particulièrement utile pour éviter des valeurs par défaut arbitraireS comme 0 ou -99 pour des données manquantes ou corrompues.\nOn en verra un exemple d\u0026rsquo;utilisation dans le TP 3.\n"});index.add({'id':1,'href':'/docs/cours2/','title':"Cours 2",'section':"Docs",'content':"Les chaînes de caractères #  Définir une chaîne de caractères #  Une chaîne de caractères (type str pour l\u0026rsquo;anglais string) est une suite ordonnée de caractères.\nPour définir une variable de ce type, il suffit d\u0026rsquo;encadrer des caractères par ' ou \u0026quot; :\nsalutation = \u0026#34;Bonjour, monsieur \u0026#34; nom = \u0026#39;Raoul\u0026#39; Des chaînes de caractères peuvent être concaténées (= assemblées) en utilisant l\u0026rsquo;opérateur + :\n\u0026#34;abc\u0026#34; + \u0026#39;def\u0026#39; 'abcdef'\nsalutation + nom 'Bonjour, monsieur Raoul'\nOn peut aussi utiliser l\u0026rsquo;opérateur * pour répéter plusieurs fois la même chaîne (dupliquer) :\n\u0026#39;a\u0026#39;*10 'aaaaaaaaaa'\n\u0026#39;-o-\u0026#39;*5 '-o--o--o--o--o-'\nEt on peut combiner * et + (en utilisant des parenthèses) :\n(\u0026#39;a\u0026#39; * 4 + \u0026#39;B\u0026#39;) * 3 'aaaaBaaaaBaaaaB'\nUne chaîne vide est définie simplement comme '' ou \u0026quot;\u0026quot;.\nEnfin, la fonction str() convertit un objet (nombre entier, nombre décimal, liste, etc.) en chaîne de caractères :\nstr(42) '42'\nstr(3.4e5) '340000.0'\nstr(3.4e20) '3.4e+20'\nLa fonction native len() permet de connaître le nombre de caractère d\u0026rsquo;une chaîne de caractères (bien noter que les espaces, les fins de ligne ou encore la ponctuation sont aussi des caractères) :\nlen(salutation) 18\nCaractères d\u0026rsquo;échappement #  Comme on peut utiliser '' ou \u0026quot;\u0026quot; pour définir une chaîne, on peut intégrer une citation dans une citation :\n\u0026#39;Et il cria : \u0026#34;Mais pourquoi ?\u0026#34;\u0026#39; 'Et il cria : \u0026quot;Mais pourquoi ?\u0026quot;'\nEt pour ajouter encore un niveau de citation, ou pour sauter une ligne, ou pour mettre une apostrophe si notre chaîne est déjà encadrée par des apostrophes, ou pour\u0026hellip; ? On utilise les caractères d\u0026rsquo;échappement, introduits par un backslash \u0026ldquo;\\\u0026rdquo; ! Exemples :\nphrase = \u0026#34;Et il cria : \\\u0026#34;Mais pourquoi ?\\\u0026#34;\u0026#34; phrase 'Et il cria : \u0026quot;Mais pourquoi ?\u0026quot;'\nprint(phrase) Et il cria : \u0026quot;Mais pourquoi ?\u0026quot;\n\u0026#39;C\\\u0026#39;est donc pour ça...\u0026#39; \u0026quot;C'est donc pour ça...\u0026quot;\nmatières = \u0026#39;Maths\\nPhysique\\nAnglais\u0026#39; matières 'Maths\\nPhysique\\nAnglais'\nprint(matières) Maths\nPhysique\nAnglais\n   Caractères d\u0026rsquo;échappement courants Signification     \\' apostrophe (')   \\\u0026quot; guillemets (\u0026quot;)   \\n fin de ligne (LF)   \\r retour chariot (CR)   \\t tabulation   \\b retour arrière (backspace)   \\\\ le caractère backslash   \\u,\\U,\\N{} caractère unicode   \\x caractères codés sur un seul byte    Si vous voulez pouvoir écrire une chaîne de caractères sans qu\u0026rsquo;un caractère d\u0026rsquo;échappement n\u0026rsquo;ait d\u0026rsquo;effet :\nchainebrute = r\u0026#34;Pour une nouvelle ligne, on utilise \\n.\u0026#34; chainebrute 'Pour une nouvelle ligne, on utilise \\\\n.'\nprint(chainebrute) Pour une nouvelle ligne, on utilise \\n.\nCela peut s\u0026rsquo;avérer pratique pour écrire le chemin d\u0026rsquo;un fichier sous windows mais écrire des slash à la place (comme sous Unix) est une autre possibilité :\nr\u0026#39;C:\\repertoire\\fichier.txt\u0026#39; 'C:\\\\repertoire\\\\fichier.txt'\nSi on doit utiliser \\n de manière répétée, le triple guillemet peut nous sauver. Encadré par ''' ou \u0026quot;\u0026quot;\u0026quot;, plus besoin de \\n pour une nouvelle ligne :\na = \u0026#34;\u0026#34;\u0026#34;un deux trois\u0026#34;\u0026#34;\u0026#34; print(a) un\ndeux\ntrois\nLes strings sont composés de caractères Unicode dans Python 3. Unicode est un standard décrivant plus de 100 000 caractères. Chaque caractère se voit assigner un nombre qui est ensuite encodé comme une suite de bytes (qui peuvent être de 8 bits pour le codage UTF-8 le plus répandu et utilisé par Python, de 16 bits, ou de 32 bits). On a ainsi :\n\u0026#39;\\u00E9\u0026#39; == \u0026#39;\\N{LATIN SMALL LETTER E WITH ACUTE}\u0026#39; == \u0026#39;\\xE9\u0026#39; True\n\\x permet d\u0026rsquo;appeler par leur code les 256 premiers caractères (premier byte).\n\u0026#39;\\x43\\x61\\x66\\xE9\u0026#39; 'Café'\nCela permet de comprendre ce que Python retourne lorsqu\u0026rsquo;on entre l\u0026rsquo;expression suivante :\n\u0026#39;prépa ST\\b\\bTSI\u0026#39; 'prépa ST\\x08\\x08TSI'\nEn effet, le retour arrière \\b a le code \\x08 (c\u0026rsquo;est le huitième caractère).\nprint(\u0026#39;prépa ST\\b\\bTSI\u0026#39;) prépa TSI\nIndexation et slicing #  Indexer une chaîne permet d\u0026rsquo;accéder à un caractère individuel de la chaîne. L\u0026rsquo;indice correspond à la position du caractère. Une chaîne de caractère est un exemple de séquence et comme pour toutes les séquences, l'indice du premier élément est 0 et l\u0026rsquo;indice du dernier élément d\u0026rsquo;une chaîne de n caractères est donc n-1.Le caractère est retourné dans une chaîne de longueur 1.\na = \u0026#39;Lycée Vieljeux\u0026#39; a[0] 'L'\na[6] 'V'\nLes indices positifs comptent dans le sens de la lecture. Mais on peut aussi compter à partir de la fin en utilisant des indices négatifs commençant par -1.\na[-1] 'x'\na[-4] 'j'\nEssayer d\u0026rsquo;indexer en dehors de la chaîne lève une exception IndexError qui stoppe l\u0026rsquo;interprète.\nlen(a) 14\na[14] IndexError: string index out of range\nLe slicing (découpage) s[i:j] permet d\u0026rsquo;extraire des éléments de la chaîne ; il extrait une sous-chaîne limitée par les caractères ciblés par les deux indices, incluant l\u0026rsquo;indice i et excluant l\u0026rsquo;indice j.\nSi le premier indice est omis s[:j], il est supposé valoir 0. Si le deuxième est omis, le slicing s\u0026rsquo;étend jusqu\u0026rsquo;à la fin de la chaîne.\na[2:9] 'cée Vie'\na[:5] 'Lycée'\na[6:] 'Vieljeux'\na[:] 'Lycée Vieljeux'\nCes règles assurent qu\u0026rsquo;une sous-chaîne est longue de j-i caractères (pour des j et i positifs) et que s[:i] + s[i:] == s.\nOn peut alors récupérer une tranche de longueur r avec s[i:i+r].\nb = \u0026#39;PrépaTSIdeVieljeux\u0026#39; b[:5] 'Prépa'\nb[5:8] 'TSI'\nb[10:] 'Vieljeux'\nContrairement à l\u0026rsquo;indexation, un slicing en dehors des limites ne lève pas d\u0026rsquo;erreur.\nb[10:20] 'Vieljeux'\nb[20:] ''\nUn troisième nombre (optionnel) dans un découpage donne un pas (qui vaut par défaut 1 s\u0026rsquo;il est omis) :\nb[::2] 'PéaSdVeju'\nb[1::2] 'rpTIeilex'\nb[-1:9:-1] 'xuejleiV'\nLe pas de -1 dans cette dernière expression correspond à une progression de droite à gauche. Cette découpe commence donc au dernier caractère (-1 en première position), avance vers la gauche caractère par caractère (-1 en dernière position) et s\u0026rsquo;arrête au caractère précédant le 9 dans ce sens, donc le caractère 10.Renverser une chaîne complète de caractère devient très simple :\na[::-1] 'xuejleiV eécyL'\nPour tester si une chaîne contient une certaine sous-chaîne, on utilise l\u0026rsquo;opérateur in (attention à la casse).\n\u0026#39;Vie\u0026#39; in b True\n\u0026#39;vie\u0026#39; in b False\nMéthodes liées aux chaînes #  Les chaînes sont des objets Python immuables, c.-à-d. qu\u0026rsquo;on ne peut pas réaffecter un caractère de la chaîne.\na[0] = \u0026#39;l\u0026#39; TypeError: 'str' object does not support item assignment\nOn peut \u0026ldquo;augmenter\u0026rdquo; une chaîne mais cela crée systématiquement une nouvelle chaîne.\na += \u0026#34; de la Rochelle\u0026#34; print(a) Lycée Vieljeux de la Rochelle\nb = \u0026#39;Léonce \u0026#39; + a[6:14] print(b) Léonce Vieljeux\nBeaucoup de méthodes permettent de manipuler et transformer les chaînes. On y a accès par la notation point \u0026ldquo;.\u0026rdquo;. Quelques méthodes utiles :\n   méthode description     center(longueur,sous-chaîne) Complète de part et d\u0026rsquo;autre la chaîne par la sous-chaîne pour que le résultat ait la taille longueur.   endswith(suffixe) Retourne True si la chaîne finit par la sous-chaîne suffixe.   startwith(préfixe) Retourne True si la chaîne commence par la sous-chaîne préfixe.   index(sous-chaîne) Retourne l\u0026rsquo;indice de début de la sous-chaîne dans le chaîne.   strip(cars) Retourne une copie de la chaîne où les éventuels caractères précisés par cars en début ou fin de chaîne sont retirés. Si cars est omis, ce sont les espaces éventuels qui sont retirés.   upper() Retourne une copie de la chaîne avec tous les caractères en majuscule.   lower() Retourne une copie de la chaîne avec tous les caractères en minuscule.   title() Retourne une copie de la chaîne où tous les mots commencent par une capitale et les autres caractères sont en minuscule.   replace(old,new) Retourne une copie de la chaîne où chaque sous-chaîne old est remplacée par la sous-chaîne new.   split(sep) Retourne une liste de sous-chaînes obtenues par découpe de la chaîne à chaque séparateur sep. Si sep n\u0026rsquo;est pas précisé, la découpe se fait sur les espaces.   join([list]) Utilise la chaîne comme un séparateur pour joindre les différentes chaînes inclues dans la liste.   isalpha() Retourne True si tous les caractères de la chaîne sont alphabétiques.   isdigit() Retourne True si tous les caractères de la chaîne sont des chiffres.    Comme ces méthodes retournent toutes une nouvelle chaîne, on peut les enchaîner.\nc = \u0026#39;--Prépa TSI du lycée Léonce Vieljeux\u0026#39; c.strip(\u0026#39;--\u0026#39;).upper().replace(\u0026#39;LÉONCE \u0026#39;,\u0026#39;\u0026#39;).center(51,\u0026#39;-\u0026#39;) '------------PRÉPA TSI DU LYCÉE VIELJEUX------------'\nAutres exemples d\u0026rsquo;utilisation des méthodes :\nd = \u0026#39;java python c++ fortran\u0026#39; d.isalpha() False\ne = d.title() e 'Java Python C++ Fortran'\nf = e.replace(\u0026#39; \u0026#39;,\u0026#39; !\\n\u0026#39;) + \u0026#39; !\u0026#39; f 'Java !\\nPython !\\nC++ !\\nFortran !'\nprint(f) Java !\nPython !\nC++ !\nFortran !\nf.index(\u0026#39;Python\u0026#39;) 7\nf[7:].startswith(\u0026#39;Py\u0026#39;) # \u0026#34;\\n\u0026#34; est compté comme un caractère unique.  True\nf[7:13].isalpha() True\ng = d.split(\u0026#39; \u0026#39;) g ['java', 'python', 'c++', 'fortran']\nh = \u0026#39; !\\n\u0026#39;.join(g) print(h, end = \u0026#39; !\u0026#39;) java !\npython !\nc++ !\nfortran !\nLa fonction print #  La fonction native print() prend en argument une liste d\u0026rsquo;objet et, de manière optionnelle, des arguments end et sep qui spécifient comment doit terminer la chaîne et quels caractères utiliser pour séparer les objets imprimés.\nnom, jour, mois = \u0026#39;Darwin\u0026#39;, 12, \u0026#39;février\u0026#39; print(nom,\u0026#39;est né le\u0026#39;,jour,mois,1809) Darwin est né le 12 février 1809\nprint(\u0026#39;C\\\u0026#39;est\u0026#39;,\u0026#39;tout\u0026#39;,\u0026#39;collé\u0026#39;,sep = \u0026#39;\u0026#39;,end = \u0026#39; !!!\\n\u0026#39;) C'esttoutcollé !!!\nprint(\u0026#39;a\u0026#39;) print(\u0026#39;b\u0026#39;) print() print(\u0026#39;c\u0026#39;) a\nb\nc\nSans argument, print imprime le caractère de fin de ligne \\n car c\u0026rsquo;est la valeur de l\u0026rsquo;argument end par défaut. Donc pour empêcher la fin de ligne après chaque appel de print, il faut donner une autre valeur à end comme end = ''.\nprint(\u0026#39;Pas de nouvelle ligne.\u0026#39;,end = \u0026#39; \u0026#39;) print(\u0026#39;La preuve !\u0026#39;) Pas de nouvelle ligne. La preuve !\nAvec un peu de pratique, on peut même utiliser print pour fabriquer des tableaux de texte :\nentête = \u0026#39;| Indice des prix des tulipes |\u0026#39; ligne = \u0026#39;+\u0026#39; + \u0026#39;-\u0026#39;*16 + \u0026#39;-\u0026#39;*13 + \u0026#39;+\u0026#39; print(ligne, entête, ligne, \u0026#39;| 23 févr. 1636 | 100 |\u0026#39;, \u0026#39;| 25 nov. 1636 | 673 |\u0026#39;, \u0026#39;| 1 févr. 1637 | 1366 |\u0026#39;, ligne, sep=\u0026#39;\\n\u0026#39;) +-----------------------------+ | Indice des prix des tulipes | +-----------------------------+ | 23 févr. 1636 | 100 | | 25 nov. 1636 | 673 | | 1 févr. 1637 | 1366 | +-----------------------------+  Formatage des chaînes de caractères #  Grâce à la méthode de chaînes de caractères .format(), la chaîne peut contenir la valeur d\u0026rsquo;une variable.\nLa syntaxe la plus simple est :\n\u0026#39;{} plus {} égale {}\u0026#39;.format(2,3,\u0026#39;cinq\u0026#39;) '2 plus 3 égale cinq'\nLes arguments de la méthode str.format() sont insérés à la place des accolades \u0026ldquo;{}\u0026rdquo; dans la chaîne principale str.\nUn nombre entre accolades se réfère à la position de l\u0026rsquo;objet passé à la méthode (on peut aussi utiliser des noms s\u0026rsquo;ils ont été affectés). Cela permet d\u0026rsquo;utiliser plusieurs fois le même argument.Rq : la zone entre les accolades s\u0026rsquo;appelle champ de formatage.\n\u0026#39;{1} plus {0} égale {2}\u0026#39;.format(2,3,\u0026#39;cinq\u0026#39;) '3 plus 2 égale cinq'\n\u0026#39;{0} plus {0} égale {1}\u0026#39;.format(2,2+2) '2 plus 2 égale 4'\n\u0026#39;{nb1} plus {nb2} égale {rés}\u0026#39;.format(nb1 = 2,nb2 = 3,rés = \u0026#39;cinq\u0026#39;) '2 plus 3 égale cinq'\nOn peut aussi spécifier une taille minimale à la chaîne qui sera insérée. Si la chaîne passée à la méthode est plus petite que la taille indiquée, elle est complétée par des espaces. La valeur de cette taille souhaitée est placée après un signe \u0026ldquo;:\u0026rdquo; dans l\u0026rsquo;accolade. La chaîne insérée est naturellement justifiée à gauche, comportement modifiable grâce à l\u0026rsquo;ajout de \u0026ldquo;\u0026gt;\u0026rdquo; ou \u0026ldquo;^\u0026rdquo;.\n\u0026#39;==={0:12}===\u0026#39;.format(\u0026#39;Python\u0026#39;) '===Python ==='\n\u0026#39;==={0:\u0026gt;12}===\u0026#39;.format(\u0026#39;Python\u0026#39;) '=== Python==='\n\u0026#39;==={0:^12}===\u0026#39;.format(\u0026#39;Python\u0026#39;) '=== Python ==='\n\u0026#39;==={0:2}===\u0026#39;.format(\u0026#39;Python\u0026#39;) # Si la taille de la chaîne insérée dépasse la taille allouée, pas de problème... '===Python==='\nCette méthode est aussi utile pour formater les nombres qui seront affichés.\nUne lettre ajoutée dans l\u0026rsquo;accolade spécifie le système de numération : d pour la base 10, b pour les binaires, x ou X pour les hexadécimaux (en minuscules ou majuscules).\na = 254 print(\u0026#39;a = {0:d} en base 10\u0026#39;.format(a)) print(\u0026#39;a = {0:b} en binaire\u0026#39;.format(a)) print(\u0026#39;a = {0:x} en héxadécimal (minuscules)\u0026#39;.format(a)) print(\u0026#39;a = {0:X} en héxadécimal (majuscules)\u0026#39;.format(a)) a = 254 en base 10 a = 11111110 en binaire a = fe en héxadécimal (minuscules) a = FE en héxadécimal (majuscules)  Si on veut que tous les nombres affichés ait la même taille (pour les aligner, par exemple), on peut ajouter des zéros à gauche pour compléter.\n\u0026#39;a = {a:05d}\u0026#39;.format(a = 254) 'a = 00254'\nPar défaut, seul le signe d\u0026rsquo;un nombre négatif est affiché. C\u0026rsquo;est là encore customisable en ajoutant un signe avant la valeur de la longueur minimum : '+' affiche toujours le signe et '' ajoute un espace devant si le nombre est positif.\na , b = -25 , 12 s = \u0026#39;{0:+5d}\\n{1:+5d}\\n= {2:+3d}\u0026#39;.format(a,b,a + b) print(s)  -25 +12 = -13  Les floats aussi ont leurs formats propres. Ajouter \u0026ldquo;e\u0026rdquo; ou \u0026ldquo;E\u0026rdquo; en fin d\u0026rsquo;accolade impose un affichage en notation scientifique alors que \u0026ldquo;f\u0026rdquo; impose l\u0026rsquo;écriture décimale. Et placer \u0026ldquo;.p\u0026rdquo; (où p est un nombre) après le signe \u0026ldquo;:\u0026rdquo; précise le nombre p de décimales que l\u0026rsquo;on souhaite (la précision).\na = 1.6235e-6 1.6235e-06\nprint(\u0026#39;{0:.1e}\u0026#39;.format(a), end = \u0026#39; \u0026#39;) print(\u0026#39;{0:.8E}\u0026#39;.format(a), end = \u0026#39; \u0026#39;) print(\u0026#39;{0:.8f}\u0026#39;.format(a), end = \u0026#39; \u0026#39;) print(\u0026#39;{0:.5f}\u0026#39;.format(a)) # Attention à ne pas tout tronquer ! 1.6e-06 1.62350000E-06 0.00000162 0.00000\n"});index.add({'id':2,'href':'/docs/cours3/','title':"Cours 3",'section':"Docs",'content':"Listes, tuples et boucles #  Listes #  Python connaît différents types de données combinées, utilisés pour regrouper plusieurs valeurs. La plus souple est la liste, qui peut être écrite comme une suite, placée entre crochets, de valeurs (éléments) séparées par des virgules. Les éléments d\u0026rsquo;une liste ne sont pas obligatoirement tous du même type, bien qu\u0026rsquo;à l\u0026rsquo;usage ce soit souvent le cas.\nliste1 = [1, \u0026#39;deux\u0026#39;, 3.14, 0] liste1 [1, 'deux', 3.14, 0]\na = 4 liste2 = [-2.5, a, liste1, a==2, True] liste2 [-2.5, 4, [1, 'deux', 3.14, 0], False, True]\nPour créer une liste vide :\nliste0 = [] liste0 []\nIndexation #  Comme les chaînes de caractères (et tout autre type de séquence), les listes peuvent être indicées et découpées (slicing) :\nliste1[1] 'deux'\nliste2[-1] True\nliste2[2][1] 'deux'\nCe dernier exemple permet de retrouver le deuxième (indice 1) élément du troisième (indice 2) élément de la liste2. Cela marche car il se trouve que liste2[2] est une liste et liste1[1] est la chaîne de caractère 'deux'. Et une chaîne de caractère étant elle-même indiçable, on peut écrire :\nliste2[2][1][-1] 'x'\nOn peut utiliser l\u0026rsquo;opérateur in pour tester l\u0026rsquo;appartenance à une liste :\n1 in liste1 True\n\u0026#39;deux\u0026#39; in liste2 False\nOn voit dans ce deuxième exemple que l\u0026rsquo;opérateur in ne regarde pas à l\u0026rsquo;intérieur des listes contenues dans les listes (on dit qu\u0026rsquo;il n\u0026rsquo;agit pas récursivement).\nLes listes sont concaténables :\nliste1 + liste2 [1, 'deux', 3.14, 0, -2.5, 4, [1, 'deux', 3.14, 0], False, True]\nLa fonction len() permet de connaître la taille d\u0026rsquo;une liste :\nlen(liste1) 4\nlen() ne compte que les éléments au premier niveau de la liste et non ceux des sous-listes :\nlen(liste2) 5\nlen(liste2[2]) 4\nSlicing #  On découpe les listes comme on a découpé les chaînes de caractères :\nL = [0., 0.1, 0.2, 0.3, 0.4, 0.5] L[1:4] [0.1, 0.2, 0.3]\nOn peut obtenir une copie renversée d\u0026rsquo;une liste en la découpant avec un pas de -1 :\nL[::-1] [0.5, 0.4, 0.3, 0.2, 0.1, 0.0]\nGrâce au pas, on peut aussi sélectionner des éléments périodiquement :\nL[1::2] [0.1, 0.3, 0.5]\nMuabilité des listes #  Contrairement aux chaînes de caractères, les listes sont des objets muables, c\u0026rsquo;est-à-dire qu\u0026rsquo;on peut modifier leur contenu.\nOn peut ainsi réaffecter des éléments :\nL1 = [1, 2, 3] L1[2] = \u0026#39;oups\u0026#39; L1 [1, 2, 'oups']\nL2 = L1 L1[1] = -99 L2 [1, -99, 'oups']\nOn remarque que modifier L1 a modifié L2. En effet, L1 et L2 référencent la même liste, stockée dans un unique espace mémoire.\nPour créer une nouvelle liste, copie de la liste de départ, mais indépendante, il y a plusieurs solutions :\nL2 = L1.copy() L3 = L1[:] L4 = list(L1) L2[1]=L3[1]=L4[1]=\u0026#39;ok\u0026#39; print(L1,L2,L3,L4) [1, -99, 'oups'] [1, 'ok', 'oups'] [1, 'ok', 'oups'] [1, 'ok', 'oups']\nSi une liste contient une variable affectée à une certaine valeur et que cette variable est réaffectée, la liste garde l\u0026rsquo;ancienne valeur car au moment de la définition de la liste, c\u0026rsquo;est la valeur de la variable et non la variable elle-même qui est stockée en mémoire.\na = 3 L3 = [1, 2, a] a = 4 L3 [1, 2, 3]\n Que deviendrait la liste2 du début après l\u0026rsquo;instruction a=2 ?\nDes affectations de tranches sont également possibles, ce qui peut modifier la taille de la liste ou même la vider complètement :\nlettres = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;] lettres[2:5] = [\u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;] lettres ['a', 'b', 'C', 'D', 'E', 'f', 'g']\nlettres[2:5] = [] lettres ['a', 'b', 'f', 'g']\nlettres[:] = [] # pour vider entièrement la liste lettres []\nMéthodes #  Le type list dispose, comme le type string, de méthodes supplémentaires, accessibles avec la notation point \u0026ldquo;.\u0026rdquo;.\nEt comme les listes sont des objets muables, elles peuvent être agrandies ou rétrécies \u0026ldquo;sur place\u0026rdquo; (sans avoir à copier le contenu dans un nouvel objet).\nPour cela, on utilise les méthodes suivantes :\n append(x) : ajoute l\u0026rsquo;élément x à la fin d\u0026rsquo;une liste. extend(liste_b) : étend la liste en y ajoutant tous les éléments de la liste_b. insert(i,x): insère l\u0026rsquo;élément x à la position i. remove(x): supprime de la liste le premier élément dont la valeur est égale à x. Une exception ValueError est levée s\u0026rsquo;il n\u0026rsquo;existe aucun élément avec cette valeur.  q = [] q.append(4) q [4]\nq.extend([6,7,8]) q [4, 6, 7, 8]\nq.insert(1,5) q [4, 5, 6, 7, 8]\nq.remove(7) q [4, 5, 6, 8]\n   méthodes utiles description     index(x) retourne l\u0026rsquo;indice de l\u0026rsquo;élément x (le plus petit s\u0026rsquo;il est là plusieurs fois)   pop() retire et retourne le dernier élément de la liste   reverse() inverse l\u0026rsquo;ordre des éléments (directement dans la liste et non dans une copie comme liste[::-1])   sort() ordonne les éléments dans la liste   copy() retourne une copie de la liste (équivaut à liste[:])   count(x) renvoie le nombre d\u0026rsquo;éléments ayant la valeur x dans la liste    q.index(8) 3\nq = [2, 0, -1, 3] q.sort() q [-1, 0, 2, 3]\nPour obtenir une copie triée d\u0026rsquo;une liste sans modifier la liste originale, on peut utiliser la fonction native sorted() :\nq = [\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;b\u0026#39;] sorted(q) ['A', 'a', 'b', 'c', 'e']\nq ['a', 'e', 'A', 'c', 'b']\nOn peut aussi utiliser cette fonction pour qu\u0026rsquo;elle retourne une liste inversée :\nsorted(q, reverse=True) ['e', 'c', 'b', 'a', 'A']\nLes méthodes append() et pop() sont adaptées pour des données structurées en piles (stack en anglais) où le principe est \u0026ldquo;dernier arrivé, premier sorti\u0026rdquo; (LIFO pour l\u0026rsquo;anglais \u0026ldquo;last in, first out\u0026rdquo;). Cela sert en particulier pour la gestion de la mémoire. Vous en réentendrez parler.\nstack = [] stack.append(1) stack.append(2) stack.append(3) stack.append(4) print(stack) [1, 2, 3, 4]\nstack.pop() 4\nprint(stack) [1, 2, 3]\nLa méthode des chaînes de caractères split() permet de créer une liste à partir d\u0026rsquo;une chaîne donnée (si non indiqué, le séparateur est l\u0026rsquo;espace).\nmois = \u0026#39;jan. févr. avr. mai juin\u0026#39; mois.split() ['jan.', 'févr.', 'avr.', 'mai', 'juin']\nnoms = \u0026#39;Alphonse et Dudule et Raoul et Ursula\u0026#39; noms.split(\u0026#39; et \u0026#39;) \u001c['Alphonse', 'Dudule', 'Raoul', 'Ursula']\nTuples #  Nous avons vu que les listes et les chaînes de caractères ont beaucoup de propriétés en commun, comme l\u0026rsquo;indexation et le slicing. Ce sont des exemples de séquences.\nIl existe également un autre type standard de séquence : le tuple.\nUn tuple consiste en différentes valeurs séparées par des virgules (avec ou sans parenthèses autour) :\nt = 1, \u0026#39;deux\u0026#39;, 3.0, 4 t \u001c(1, 'deux', 3.0, 4)\nComme un tuple est une séquence, il peut être indexé ou découpé.\nt[1] 'deux'\nt[1:3] ('deux', 3.0)\nt[0] = \u0026#39;essai de réaffectation\u0026#39; TypeError: 'tuple' object does not support item assignment\nLe dernier exemple montre que les tuples sont des objets immuables.\nPour créer un tuple vide, pas de problèmes :\nt = () Par contre, c\u0026rsquo;est plus compliqué de créer un tuple ne contenant qu\u0026rsquo;un élément (un singleton) :\nt = (1,) Si les tuples peuvent sembler similaires aux listes, ils sont généralement utilisés dans des cas différents et pour des raisons différentes.\nLes tuples sont immuables et contiennent souvent des séquences hétérogènes d\u0026rsquo;éléments auxquelles on peut accéder par \u0026ldquo;déballage\u0026rdquo;.\nL\u0026rsquo;instruction t = 1, 'deux', 3.0 est un exemple d\u0026rsquo;emballage de tuple : les valeurs 1, 'deux', 3.0 sont emballées ensemble.\nOn peut ensuite déballer le tuple. Comme on l\u0026rsquo;a déjà vu, cela permet des affectations multiples.\nt = 1, \u0026#39;deux\u0026#39;, 3.0 x , y, z = t print(x,y,z) 1 deux 3.0\nLes tuples sont utiles lorsqu\u0026rsquo;une séquence ne peut ou ne devrait pas être modifiée.\nObjets itérables #  Les chaînes de caractères, les listes et les tuples sont des objets itérables = des objets composés d\u0026rsquo;un ensemble d\u0026rsquo;éléments ordonnés qui peuvent être sélectionnés un par un.\nL\u0026rsquo;opérateur * permet de déballer un itérable (unpack). Cela peut s\u0026rsquo;avérer pratique lorsqu\u0026rsquo;une fonction prend en argument plusieurs éléments.\nPrenons l\u0026rsquo;exemple de la fonction math.hypot(x,y) qui calcule $$\\sqrt{a^2+b^2}$$ :\nimport math c = [3, 4] math.hypot(c) TypeError: hypot expected 2 arguments, got 1\nmath.hypot(*c) 5.0\nC\u0026rsquo;est bien plus simple que d\u0026rsquo;aller récupérer les éléments de la liste en les indexant (math.hypot(c[0],c[1])).\nBoucle for #  C\u0026rsquo;est souvent utile de récupérer et d\u0026rsquo;utiliser un à un chacun des éléments d\u0026rsquo;un objet itérable.\nLa syntaxe Python pour une telle opération est plutôt naturelle : for élément in objet itérable :\nliste_de_fruits = [\u0026#39;pomme\u0026#39;, \u0026#39;banane\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;pamplemousse\u0026#39;] for fruit in liste_de_fruits : print(fruit) pomme\nbanane\norange\npamplemousse\nChacun son tour, un élément de l\u0026rsquo;objet itérable liste_de_fruits est affecté à la variable fruit dans le block d\u0026rsquo;instructions qui suit le signe :.Chaque ligne de ce bloc, le corps de la boucle, doit être indentée par le même nombre d\u0026rsquo;espaces (c\u0026rsquo;est recommandé d\u0026rsquo;utiliser 4 espaces ou une tabulation par niveau d\u0026rsquo;indentation). C\u0026rsquo;est cette indentation qui permet, en Python, de savoir qu\u0026rsquo;on est ou non toujours dans la boucle. La structuration du code par indentation est une des principales caractéristiques du langage Python (et un des principaux griefs contre lui).\nUne boucle peut très bien être imbriquée dans une autre boucle (il faut indenter le corps de la boucle intérieure d\u0026rsquo;un niveau de plus) :\nfor fruit in liste_de_fruits : for lettre in fruit : print(lettre,end =\u0026#39;.\u0026#39;) print() p.o.m.m.e.\nb.a.n.a.n.e.\no.r.a.n.g.e.\np.a.m.p.l.e.m.o.u.s.s.e.\nLe end = '.' du print dans la boucle intérieure permet de placer un point après chaque lettre tout en évitant la nouvelle ligne à chaque appel de la fonction.\nLe print() de la boucle extérieure permet d\u0026rsquo;aller à la ligne à la fin de chaque mot.\nLa fonction range() #  Si vous devez itérer sur une suite d\u0026rsquo;entiers, la fonction native range() est faite pour cela. Elle génère des suites arithmétiques :\nfor i in range(5) : print(i, end = \u0026#39; \u0026#39;) 0 1 2 3 4\nfor i in range(1,5) : print(i, end = \u0026#39; \u0026#39;) 1 2 3 4\nfor i in range(0,6,2) : print(i, end = \u0026#39; \u0026#39;) 0 2 4\nfor i in range(10,0,-2) : print(i, end = \u0026#39; \u0026#39;) 10 8 6 4 2\nrange() prend donc trois arguments (entier de départ, entier de fin, le pas) dont deux optionnels (range commence à zéro et le pas vaut 1 par défaut).\nLe dernier entier produit par range est celui précédant la valeur de l\u0026rsquo;entier de fin.\n Exemple : écrire les 20 premiers termes de la suite de Fibonacci définie par $$a_1=1$$, $$a_2=1$$ et la relation de récurrence $$a_i = a_{i-1}+a_{i-2}$$.\nPremière méthode : ajouter des éléments à une liste\nn = 20 fib = [1,1] for i in range(2,n) : fib.append(fib[i-1]+fib[i-2]) print(*fib) 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765\nDeuxième méthode (moins consommatrice de mémoire) : on peut se débrouiller pour ne stocker à tout moment que deux éléments.\nn = 20 a, b = 1, 1 print(a, b, end = \u0026#34; \u0026#34;) for i in range (2,n) : a, b = b, a+b print(b, end = \u0026#34; \u0026#34;) 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765\nenumerate #  Comme range() produit une suite d\u0026rsquo;entiers, on peut l\u0026rsquo;utiliser pour afficher l\u0026rsquo;indice de l\u0026rsquo;élément d\u0026rsquo;une liste à chaque itération dans une boucle for :\nmarsupiaux = [\u0026#39;kangooroo\u0026#39; , \u0026#39;koala\u0026#39; , \u0026#39;wombat\u0026#39;] for i in range(len(marsupiaux)) : print(i, \u0026#39; : \u0026#39;, marsupiaux[i]) 0 : kangooroo\n1 : koala\n2 : wombat\nOn peut réaliser la même chose plus efficacement en utilisant enumerate().Cette fonction prend un objet itérable en argument et produit, pour chaque élément de l\u0026rsquo;objet, un tuple (numéro, élément) associant un numéro à l\u0026rsquo;élément lui-même.\nfor i, marsupial in enumerate(marsupiaux) : print(i, \u0026#39; : \u0026#39;, marsupial) 0 : kangooroo\n1 : koala\n2 : wombat\nChaque tuple (numéro, élément) a été déballé dans la boucle for en les affectant aux variables i et marsupial.\nOn peut faire commencer la numérotation d'enumerate à une autre valeur que 0 (mais le numéro ne correspondra alors plus à l\u0026rsquo;indice).\nfor i, marsupial in enumerate(marsupiaux,1) : print(i, \u0026#39; : \u0026#39;, marsupial) 1 : kangooroo\n2 : koala\n3 : wombat\nzip #  Pour faire des boucles sur plusieurs séquences en même temps, on peut utiliser la fonction zip() afin d’associer les éléments des différentes séquences entre eux. Elle crée un objet itérable composé de tuples couplant les termes de même indice des différentes séquences en argument.\na = [1, 2, 3, 4] b = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] for pair in zip(a,b) : print(pair) (1, 'a')\n(2, 'b')\n(3, 'c')\n(4, 'd')\nCe n\u0026rsquo;est donc pas grave que les listes n\u0026rsquo;aient pas la même taille, zip les associe tant qu\u0026rsquo;elle peut.\nOn peut aussi utiliser zip pour dézipper des séquences de tuples :\nz = ((1,\u0026#39;a\u0026#39;),(2,\u0026#39;b\u0026#39;),(3,\u0026#39;c\u0026#39;),(4,\u0026#39;d\u0026#39;)) A , B = zip(*z) print(A, B, sep = \u0026#39;\\n\u0026#39;) (1, 2, 3, 4) \n('a', 'b', 'c', 'd')\nComme zip ne copie pas les éléments vers un nouvel objet, cette méthode est rapide et économe en mémoire ; mais cela signifie aussi qu\u0026rsquo;on ne peut itérer sur les éléments zippés qu\u0026rsquo;une seule fois et qu\u0026rsquo;on ne peut pas les indicer.\nListe par compréhension #  La construction de liste par compréhension permet de créer une liste à partir d\u0026rsquo;un autre objet itérable en une seule ligne de code.\nPar exemple, étant donné une liste de nombres, une liste des carrés de ces nombres peut être créée ainsi :\nxliste = [1, 2, 3, 4, 5, 6] x2liste = [x**2 for x in xliste] La méthode classique prend un peu plus de temps pour s\u0026rsquo;exécuter et sa syntaxe est plus lourde :\nx2liste = [] for x in xliste : x2liste.append(x**2) x2liste [1, 4, 9, 16, 25, 36]\nComme on le voit, une construction d\u0026rsquo;une liste par compréhension est analogue à une définition mathématique.\nOn peut aussi placer des conditions dans la définition :\n[x**2 if x % 2 else x**3 for x in xliste] [1, 8, 9, 64, 25, 216]\nOn a ici mis au carré les nombres impairs et au cube les nombres pairs de xliste.\nOn l\u0026rsquo;a dit, la construction par compréhension se base sur n\u0026rsquo;importe quel itérable, pas forcément une liste :\n[x**3 for x in range(1,10)] [1, 8, 27, 64, 125, 216, 343, 512, 729]\n[w.upper() for w in \u0026#39;abc xyz\u0026#39;] ['A', 'B', 'C', ' ', 'X', 'Y', 'Z']\nEnfin, une liste construite par compréhension peut être imbriquée.Le code suivant va permettre d\u0026rsquo;applatir une liste de listes :\nvliste = [[1, 2, 3],[4, 5, 6],[7, 8, 9]] [c for v in vliste for c in v] [1, 2, 3, 4, 5, 6, 7, 8, 9]\nLa première boucle parcourt les différentes listes intérieurs de vliste et la deuxième boucle parcourt les éléments de ces listes intérieures.\n Exemple : supposons que l\u0026rsquo;on veuille transposer une matrice M 3 × 3.\n Sans compréhension de liste :  M = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] MT = [[0,0,0],[0,0,0],[0,0,0]] for i in range(3) : for j in range(3) : MT[i][j] = M[j][i] for l in MT : print(l) [1, 4, 7] [2, 5, 8] [3, 6, 9]  Avec compréhension de liste :  MT = [] for i in range(3) : MT.append([col[i] for col in M]) for l in MT : print(l) [1, 4, 7] [2, 5, 8] [3, 6, 9] Notons toutefois que le package de programmation scientifique NumPy (étudié plus tard) propose une méthode bien meilleure pour gérer les matrices.\nDictionnaires #  \u0026ldquo;dictionnary\u0026rdquo; est le nom donné par Python a une structure de données très pratique : la table de hachage.\n"});})();