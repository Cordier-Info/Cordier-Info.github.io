'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/cours1/','title':"Cours1",'section':"Docs",'content':"Python - Introduction Python est un langage de programmation interprété développé par Guido van Rossum en 1989. Langage impératif de haut-niveau doté d'une syntaxe simple, Python s'adapte à de nombreux contextes grâce à sa modularité ; une importante librairie de modules et packages permet en effet d'étendre ses capacités.\nShell et IDE Python possède son propre shell (interface en ligne de commande) : l'utilisateur entre une commande Python qui est interprétée immédiatement lorsque Entrée est tapée. Au lancement, le shell Python, poli, se présente :\nPython 3.7.3 (default, Mar 27 2019, 16:54:48)\n[Clang 4.0.1 (tags/RELEASE_401/final)] :: Anaconda, Inc. on darwin\nType \u0026quot;help\u0026quot;, \u0026quot;copyright\u0026quot;, \u0026quot;credits\u0026quot; or \u0026quot;license\u0026quot; for more information.\n\u0026gt;\u0026gt;\u0026gt;\nLes 3 chevrons sont l'invite (ou prompt) où les commandes seront écrites.\nIPython, un shell plus évolué, utilise [1] comme invite (où le chiffre dans les crochets s'incrémente à chaque commande.\nPour sortir du shell classique, il faut taper exit(), et exit ou quit pour sortie du shell IPython.\nOn peut tout à fait exécuter des commandes Python une à une dans le shell.\nUne commande qui renvoie un résultat est appelée expression, alors qu'une commande qui ne renvoie rien est une instruction.\nToute fonction est une expression, mais certaines ont en plus un effet sur l'environnement comme print() qui permet d'afficher une chaîne de caractère dans le shell ou dans un fichier (elle retourne aussi la valeur none qui est omise dans ce cas par le shell).\n5 + 2 7\na = 7print(a) 7\nPour des projets plus complexes nécessitant de nombreuses instructions ou expressions, on écrit l'ensemble de ces commandes (=le programme) dans un éditeur de texte et on enregistre le fichier avec une extension .py. On demande alors à l'interprète Python d'exécuter l'ensemble du script en utilisant la commande python nom_du_fichier.py dans le shell de l'OS. L'interprète n'affiche plus, dans ce cas, les différents retours dans le shell, seuls les effets ont un... effet.\nIl est important d'ajouter des commentaires à son code dans le script afin qu'il soit plus facilement compréhensible et donc partageable. Pour ce faire on les place derrière un hastag # pour qu'ils soient ignorés par l'interprète.\nMais le plus simple est d'utiliser un environnement de travail (IDE pour \u0026quot;integrated development environment\u0026quot;) qui combine un éditeur de texte et un shell Python et qui permet d'exécuter le script entier ou une partie directement via un bouton run ou exécuter. Les oraux de Centrale \u0026quot;Mathématiques 2\u0026quot; et \u0026quot;Physique-chimie 2\u0026quot; utilisent l'IDE Pyzo. Les ordinateurs du lycée ont les IDE EduPython et Pyzo disponibles sur le serveur S:\\. Vous pouvez aussi utiliser pour dépanner l'IDE minimale en ligne Repl.it depuis le repository du TP.\n\nTypes de nombres Les nombres sont parmi les objets Python les plus basiques.\nIl en existe 3 types :\n les entiers (type : int).\nIls n'ont pas de limite de taille (à part la mémoire vive disponible de l'ordinateur).\nL'arithmétique sur les entiers est exacte.\n les nombres à virgule flottante (type : float).\nCe sont des nombres décimaux. Ils sont stockés en binaire jusqu'à une certaine précision (l'équivalent de 15 ou 16 chiffres en écriture décimale sur la plupart des systèmes). Ils ne peuvent donc en général pas représenter fidèlement un nombre réel. On reviendra sur ce point plus tard.\nRq : c'est un point \u0026quot;.\u0026quot; et non une virgule \u0026quot;,\u0026quot; qui sépare la partie entière de la partie décimale en Python. les nombres complexes (type : complex).\nNombre de type 4+3j (la partie imaginaire est notée j en python).\n4+3j peut aussi s'écrire complex(4,3).  Taper un nombre dans le shell Python renvoie simplement la nombre :\n5 5\n5. 5.0\n0.10 0.1\n0.0001 0.0001\n0.0000999 9.99e-05\nLes nombres inférieurs à 0,0001 sont écrits en notation scientifique.\nOn peut changer le type d'un nombre :\nfloat(5) 5.0\nint(5.2) 5\nint(5.9) 5\ncomplex(3.) (3+0j)\ncomplex(0.,3.) 3j\nOn remarque que la transformation en entier d'un nombre décimal prend en fait sa partie entière.\nArithmétique de base Les opérateurs de base utilisables en Python sont :\n   symbole opération     + addition   - soustraction   * multiplication   / division décimale   // division euclidienne   % modulo (reste de la division euclidienne)   ** puissance    Règles de priorités des opérations :\n** \u0026gt; { * ,/ , // , % } \u0026gt; { + ,- }\n6 / 2 / 4 # comme 3 / 4 0.75\n6 / (2 / 4) # comme 6 / 0.5 12.0\n2**2**3 # comme 2**(2**3) == 2**8 256\n(2**2)**3 # comme 4**3 64\nOn remarque que les opérations de priorité égale sont évaluées de gauche à droite à l'exception des puissances (ce qui correspond à évaluer de haut en bas les exposants).\nMéthodes et attributs En Python, tout, y compris un nombre, est un objet ayant certains attributs accessibles grâce à la notation \u0026quot;point\u0026quot; : \u0026lt;objet\u0026gt;.\u0026lt;attribut\u0026gt;. Certains attributs sont des simples valeurs : les nombres complexes ont par exemple les attributs real et imag qui sont les parties réelles et imaginaires d'un nombre complexe.\n(3+4j).imag 4.0\nD'autres attributs sont des méthodes : des fonctions qui modifient leur objet d'une façon ou d'une autre.\nPar exemple, les nombres complexes ont la méthode conjugate qui retourne le complexe conjugué :\n(3+4j).conjugate() (3-4j)\nFonctions mathématiques round et abs sont deux fonctions proposées par défaut (natives).\nabs retourne la valeur absolue d'un nombre entier ou décimal, ou le module d'un nombre complexe (c'est un exemple de polymorphisme : comportement différent en fonction du type de l'argument).\nabs(-7.2) 7.2\nabs(3+4j) 5.0\nround arrondi un nombre décimal à l'entier le plus proche (attention, la convention utilisée lorsque la décimale vaut 5 est l'arrondi bancaire ou arrondi au pair le plus proche : au-dessus lorsque la partie entière est impaire et en dessous lorsqu'elle est paire).\nround(7.6) 8\nround(7.5) 8\nround(8.5) 8\nPython est un langage d'une grande modularité : des fonctionnalités supplémentaires sont accessibles en important des modules ou des packages qui ne sont pas chargés par défaut (ce qui permet de ne pas encombrer la mémoire).\nBeaucoup de fonctions mathématiques utiles peuvent ainsi être ajoutées grâce au module math, importé grâce à la déclaration import math.\nimport mathmath.exp(-1.5) 0.22313016014842982\nmath.cos(0) 1.0\nmath.sqrt(9) 3.0\nL'ensemble des fonctions disponibles dans le module sont répertoriées dans sa documentation en ligne et les plus utiles sont dans le tableau suivant (les angles des fonctions trigonométriques sont supposés en radians) :\n   nom de la fonction signification nom de la fonction signification     math.sqrt(x) $\\sqrt{x}$ math.atan(x) $\\arctan (x)$   math.exp(x) $e^x$ math.sinh(x) $\\sinh (x)$   math.log(x) $\\ln (x)$ math.cosh(x) $\\cosh (x)$   math.log(x,b) $\\log_b(x)$ math.tanh(x) $\\tanh (x)$   math.log10(x) $\\log_{10}(x)$ math.asinh(x) $\\text{arsinh} (x)$   math.sin(x) $\\sin (x)$ math.acosh(x) $\\text{arcosh} (x)$   math.cos(x) $\\cos (x)$ math.atanh(x) $\\text{artanh} (x)$   math.tan(x) $\\tan (x)$ math.hypot(x,y) norme euclidienne $\\sqrt{x2+y2}$   math.asin(x) $\\arcsin (x)$ math.degrees(x) convertit x des radians aux degrés   math.acos(x) $\\arccos (x)$ math.radians(x) convertit x des degrés aux radians    Le module math propose aussi deux attributs très utiles : math.pi et math.e qui donnent les valeurs de $\\pi$ et $e$.\nIl est possible d'importer le module math par la commande from math import * afin d'accéder à ses fonctions directement :\nfrom math import *cos(pi) -1.0\nBien que cela puisse être pratique pour des petites interactions avec le shell, ce n'est pas recommandé pour des programmes plus conséquent car cela peut générer confusions et conflits de noms.\nOn peut bien sûr composer les fonctions :\nmath.degrees(math.acos(math.sqrt(3)/2)) 30.000000000000004\nNotons que le nombre affiché diffère du résultat exact attendu $\\arccos(\\sqrt{3}/2)=30°$ (on reviendra sur ce point plus tard).\nVariables Lorsqu'un objet, comme un float, est créé dans un programme Python, une certaine place en mémoire lui est allouée. Cette place est repérée par une adresse dont la valeur peut être obtenue grâce à la fonction id().\nid(3.7) 4387417928\nIl est beaucoup plus pratique de pouvoir récupérer une valeur en mémoire grâce à un petit nom plutôt que par son adresse. C'est à ça que servent les variables. Une variable est liée à un objet grâce à une affectation et identifie cet objet pour les calculs suivants.\na = 3b = -0.1a * b -0.30000000000000004\nÀ nouveau, le résultat décimal affiché est un peu étrange mais nous y reviendrons.\nSi on veut pouvoir utiliser le résultat de a * b pour des calculs ultérieurs, il faut lui aussi le stocker en mémoire.\nc = a * bc -0.30000000000000004\nRemarque : contrairement à d'autres langages (comme le C), une variable n'a pas besoin d'être déclarée en Python, mais il faut néanmoins initialiser sa valeur pour ne pas provoquer d'erreur. Le type de la variable est induit au moment de cette première affectation.\n3+x NameError: name 'x' is not defined\nOn peut interroger le type d'une variable avec la fonction type() :\ntype(c) float\nRègles sur les noms de variables :\n ils sont sensibles à la casse (minuscule ou majuscule) ils peuvent contenir n'importe quelles lettres ou chiffres et le tiret-bas \u0026quot;_\u0026quot; mais ne doivent pas commencer par un chiffre. certains noms sont interdits (attention en particulier à lambda) :  and assert break class continue def del elif else except finally for from global if import in is lambda nonlocal not or pass print raise return try while yield\nIl est important pour la lisibilité de son code de donner les noms les plus explicites possibles aux variables. Les rapports de jury le répète tous les ans... Rapport 2019 de l'épreuve de Centrale par exemple :\n Des noms de variables explicites aident à la compréhension du code. De trop nombreux candidats utilisent des noms de variables quelconques (a, b, c...) ce qui nuit à la compréhension du programme. La clarté du programme (en particulier le choix des noms de variables) ainsi que la présence de commentaires opportuns sont prises en compte dans l’évaluation.\n Une affectation ne retourne rien (c'est une instruction) mais a un effet sur la mémoire : l'adresse de la variable est modifiée à chaque nouvelle affectation. C'est ce qui rend possible les réaffectations à partir de la variable elle-même.\nid(a) 4304751488\nid(a+1) 4304751520\na = a + 1id(a) 4304751520\nLes réaffectations de variable de ce type sont si fréquentes qu'il existe une notation raccourcie : +=, -=, *=, /=, //=, %=.\nAinsi, a += 1 équivaut à a = a + 1 et b /= 5 équivaut à b = b/5.\nPython permet d'affecter plusieurs variables simultanément (en parallèle) :\na , b = 3.2 , -2a 3.2\nb -2\nComment faire si on veut permuter les valeurs auxquelles sont liées deux variables ? Dès qu'on écrit a = b, la valeur initiale de a est perdue et si on commence par b = a, c'est la valeur initiale de b qui est perdue. Il faudrait donc utiliser une variable temporaire et écrire : tmp = a, a = b et b = tmp. Mais l'affectation parallèle de Python va nous permettre d'être plus élégants. Il suffit en effet d'une petite ligne :\na , b = b , aa -2\nb 3.2\nL'affectation parallèle repose sur le packing et l'unpacking de tuples, mais on verra ça dans un prochain cours.\n\\pagebreak  Comparaison et logique Les différents comparateurs utilisables en Python sont :\n   comparateur signification       != différent de   \u0026gt; supérieur à   \u0026lt; inférieur à   \u0026gt;= supérieur ou égal à   \u0026lt;= inférieur ou égal à    Le résultat d'une comparaison est un objet booléen (type bool) qui a deux valeurs possibles : True ou False.\n7 == 8 False\n4 \u0026gt;= 3.8 True\na = 4 \u0026lt; 3 type(a) bool\nIl faut bien noter la différence entre = qui affecte une valeur à une variable et == qui compare deux valeurs.\nDu fait de la précision finie des nombres décimaux, leur comparaison peut s'avérer dangereuse :\na , b = 0.01 , 0.1**2a == b False\nEn effet :\na 0.01\nb 0.010000000000000002\nLes comparaisons peuvent être modifiées et enchaînées grâce aux opérateurs logiques and (et), or (ou inclusif), et not (non).\n7.0 \u0026gt; 4 and -1 \u0026gt;= 0 False\n5 \u0026lt; 4 or 1 != 0 True\nDans des expressions composées comme celles-ci, les opérateurs de comparaison sont évalués en premier puis vient le tour des opérateurs logiques.\nnot 7.5 \u0026lt; 0.9 or 4 == 4 True\nnot (7.5 \u0026lt; 0.9 or 4 == 4) False\nUn nombre entier ou décimal peut être considéré comme un booléen dans des expressions logiques. Dans ce cas, tout nombre différent de zéro est considéré comme vrai.\n18.7 and 5 \u0026lt; 8 True\nOn parle d'égalité de valeurs (testée par l'opérateur ==) lorsque deux variables référencent la même valeur et d'égalité physique lorsqu'il s'agit du même objet ayant un emplacement mémoire unique. L'égalité physique implique bien sûr l'égalité de valeurs.\nPour tester l'égalité physique de deux variables, on utilise l'opérateur is.\na = 257 b = 257 a == b True\na is b False\na is 257 False\nid(a) 4396188400\nid(b) 4396188144\nid(257) 4396188272\nc = 256 d = 256 c is d True\nc is 256 True\nid(c) 4304759584\nid(d) 4304759584\nid(256) 4304759584\nPython garde en cache les petits entiers (de -5 à 256 généralement), souvent utilisés, pour améliorer les performances. a et b sont alors tout deux liés à l'espace mémoire de l'objet 256. Ils correspondent donc bien au même objet physique.\nType None Enfin, pour nous aider à traiter les cas où aucune valeur définie n'est possible (soit parceque la valeur conduirait à une erreur où n'aurait pas de sens), Python propose d'utiliser la valeur None de type NoneType.\nC'est particulièrement utile pour éviter des valeurs par défaut arbitraireS comme 0 ou -99 pour des données manquantes ou corrompues.\nOn en verra un exemple d'utilisation dans le TP 3.\n"});})();